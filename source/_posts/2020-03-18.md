---
title: Spring 五个事务隔离级别和七个事务传播行为
date: 2020-03-18 15:15:49
index_img: http://image.wangxiaohuan.com/blog/image/20210406212513.png
banner_img: http://image.wangxiaohuan.com/blog/image/20210406212513.png
categories:
- Spring
tags:
- 事务
---



### TransactionDefinition 接口五个事务隔离级别

**ISOLATION_DEFAULT** :这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.另外四个与JDBC的隔离级别相对应

**ISOLATION_READ_UNCOMMITTED** :这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读

**ISOLATION_READ_COMMITTED** :保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。

**ISOLATION_REPEATABLE_READ** :这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。

**ISOLATION_SERIALIZABLE** :这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻像读。

### TransactionDefinition 接口七个事务传播行为

**PROPAGATION_REQUIRED** :如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。

**PROPAGATION_SUPPORTS** :如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。

**PROPAGATION_MANDATORY** :如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。

**PROPAGATION_REQUIRES_NEW** :总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。

**PROPAGATION_NOT_SUPPORTED** :总是非事务地执行，并挂起任何存在的事务。

**PROPAGATION_NEVER** :总是非事务地执行，如果存在一个活动事务，则抛出异常

**PROPAGATION_NESTED** :如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行

### 四种数据隔离级别

**Serializable** ：最严格的级别，事务串行执行，资源消耗最大；
**REPEATABLE READ** ：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读取”和“不可重复读取”的情况，但是带来了更多的性能损失。

**READ COMMITTED** :大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读取”。该级别适用于大多数系统。

**Read Uncommitted** ：保证了读取过程中不会读取到非法数据。

### 脏读、不可重复读、幻读

**脏读** ：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。

**不可重复读** ：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两 次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为可重复读。

**幻读** : 是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。 同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。